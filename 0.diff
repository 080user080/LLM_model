--- a/improved_logic.py
+++ b/improved_logic.py
@@ -223,73 +223,72 @@ def _narrator_fallback(text: str, narrator_tag: str) -> str:
             out.append(line)
             continue
         if dialog_start.match(stripped):
             in_block = False
             out.append(line)
             continue
         if not in_block:
             out.append(f"{narrator_tag}: {line}")
             in_block = True
         else:
             out.append(line)
     return "".join(out)
 
 
 def _demote_g1_dialogs(text: str) -> str:
     """Якщо після фолбеку зʼявилися #g1: перед діалогами — міняємо на #g?."""
     pat = re.compile(rf"(?m)^(\s*)#g1\s*:\s*(?=[{DASHES}«\"„“”'’])")
     return pat.sub(r"\1#g?: ", text)
 
 
 def _collapse_same_tags(text: str) -> str:
     """Згортає повтори однакових тегів (#gN) у суміжних рядках (крім діалогів і #g?)."""
     lines = text.splitlines(keepends=True)
     out: List[str] = []
     prev_tag: Optional[str] = None
-    tag_re = re.compile(r"^(\s*)(#g(?:\d+|\?))\s*:\s*(.*?)(\r?\n)?$", re.DOTALL)
+    tag_re = re.compile(r"^(\s*)(#g(?:\d+|\?))\s*:(\s*)(.*?)(\r?\n)?$", re.DOTALL)
     is_dialog = re.compile(r"^\s*(?:[-–—]|[«\"„“”'’])")
 
     for line in lines:
         m = tag_re.match(line)
         if not m:
             if line.strip():
                 prev_tag = None
             out.append(line)
             continue
-        indent, tag, rest, nl = m.groups()
-        nl = nl or "\n"
+        indent, tag, post_ws, rest, nl = m.groups()
 
         if tag == "#g?":
             out.append(line)
             prev_tag = tag
             continue
         if is_dialog.match(rest.lstrip()):
             out.append(line)
             prev_tag = tag
             continue
         if prev_tag and tag.lower() == prev_tag.lower():
-            out.append(f"{indent}{rest}{nl}")
+            out.append(f"{indent}{post_ws}{rest}{nl or ''}")
         else:
             out.append(line)
             prev_tag = tag
 
     return "".join(out)
 
 
 # ---- Публічне API ----
 
 def process_dialogs(
     input_path: str,
     legend_text: str = "",
     workers: int = 1,
     output_path: Optional[str] = None,
 ) -> Tuple[str, str]:
     logs_parts: List[str] = []
     if not os.path.isfile(input_path):
         return "", f"Файл не знайдено: {input_path}"
 
     with open(input_path, "r", encoding="utf-8") as f:
         src = f.read()
 
     legend_map, narrator_tag = parse_legend_text(legend_text)
     nar_tag = narrator_tag or "#g1"
     ctx = ProcessingContext(legend=legend_map, narrator_tag=nar_tag)
