from transformers import pipeline

# 1. Визначення моделі та токенізатора
MODEL_NAME = "ukr-detect/ukr-emotions-classifier"

# 2. Створення словника для перекладу англійських міток на українські
EMOTION_MAP = {
    'Joy': 'Радість',
    'Anger': 'Злість',
    'Fear': 'Страх',
    'Disgust': 'Огида',
    'Surprise': 'Здивування',
    'Sadness': 'Смуток',
    'None': 'Немає емоції'
}

# 3. Визначення тегів для емоцій (згідно з вашим запитом)
TAGS = {
    'Fear': '#heart',  # Прямий сигнал для напруженої сцени (страх)
    'Anger': '#v'      # Прямий сигнал для злості
}

# 4. Створення пайплайну класифікатора
try:
    # Використання top_k=None, щоб отримати всі бали, як рекомендовано в попередженні
    classifier = pipeline(
        "text-classification",
        model=MODEL_NAME,
        tokenizer=MODEL_NAME,
        top_k=None
    )
except Exception as e:
    print(f"❌ Помилка завантаження моделі. Перевірте підключення до Інтернету або назву моделі: {e}")
    exit()

# 5. Приклад речення для аналізу (остання складна сцена)
text_to_analyze = "Він нічого не чув, а коли розплющив очі, то нікого не бачив. Але він знав, що хтось там є. Не зайшов через двері, тож, мабуть, зайшов через відчинене вікно. «Це просто дурниці, — сказав собі Елвін, — тут немає жодної душі». Але він лежав нерухомо, весь сміх зник з нього, бо відчував це — хтось стоїть там. «Ні, це кошмар, ось і все, мене досі лякає думка про те, що Червоні спостерігають за мною зовні, або, можливо, погроза Анни, щось таке: якщо я просто лежатиму тут із заплющеними очима, все мине»"


# ==========================================================
# 6. ЗАПУСК КЛАСИФІКАЦІЇ ТА ГІБРИДНА ПОСТ-ОБРОБКА
# ==========================================================

# 6.1. Запуск класифікації
results = classifier(text_to_analyze)

# 6.2. Визначення словника ключових слів для корекції
correction_keywords = {
    # Корекція Злості: маркери агресії та роздратування
    'Anger': ["кипіло", "дратував", "кулак", "злість", "палала", "вдарив", "напружене", "викликом", "роздратування"],
    
    # Корекція Огиди: маркери фізичної/візуальної відрази
    'Disgust': ["відрази", "відвернутися", "холод у животі", "огидно", "забрудненим", "нудило", "видовища"],
    
    # Корекція Здивування: маркери несподіванки та шоку
    'Surprise': ["не вірячи", "очам", "зупинився", "перехопило", "незвичним", "неймовірним", "не вкладається", "здивувався"], 
    
    # Корекція Страху/Напруги: маркери небезпеки, травми, стресу
    'Fear': ["кровотечу", "скло", "уламки", "застрягли", "глибоко", "порізу", "рани", "небезпечно", "венами", "протяг", "холодний"],
    
    # Корекція Смутку/Відчаю: маркери болю, втрати, депресії
    'Sadness': ["боліла", "боліло", "бажання смерті", "найгірше відчуття", "не міг згадати", "лежав", "не мертвий", "важко", "біль", "порожні очі"]
}

text_lower = text_to_analyze.lower()
applied_correction = False

# Створюємо словник для зручної модифікації
emotion_scores = {item['label']: item['score'] for item in results[0]}


# 6.3. Перевірка та корекція для кожної цільової емоції
for emotion_label_en, keywords in correction_keywords.items():
    
    found_keyword = any(keyword in text_lower for keyword in keywords)
    
    if found_keyword:
        # Корекція буде застосована, якщо знайдено ключове слово
        # і якщо модель невпевнена (бал менше 0.5)
        if emotion_scores.get(emotion_label_en, 0.0) < 0.5:
            applied_correction = True
            print(f"\n--- Виявлено ключові слова для {EMOTION_MAP.get(emotion_label_en, emotion_label_en)}. Застосовується корекція. ---")
            
            # Штучно встановлюємо високий бал для цільової емоції
            emotion_scores[emotion_label_en] = 0.95 
            
            # Логіка зниження інших конкуруючих класів (якщо вони були високими)
            if emotion_scores.get('Sadness', 0.0) > 0.5 and emotion_label_en != 'Sadness':
                 # Знижуємо Sadness, якщо він помилково домінує
                 emotion_scores['Sadness'] = 0.2
            
            if emotion_scores.get('None', 0.0) > 0.5:
                # Знижуємо None, якщо він помилково домінує
                emotion_scores['None'] = 0.1
            

# 6.4. Оновлення результатів для виведення
if applied_correction:
    results[0] = [{'label': label, 'score': score} for label, score in emotion_scores.items()]
    
# Сортуємо результати
sorted_emotions = sorted(results[0], key=lambda x: x['score'], reverse=True)


# ==========================================================
# 7. Обробка та виведення результатів
# ==========================================================
print("==============================================")
print(f"Аналізований текст: '{text_to_analyze}'\n")
print("Знайдені емоції:")
print("==============================================")

# Виводимо всі бали, щоб бачити ефект корекції
THRESHOLD = 0.0 

for emotion in sorted_emotions:
    label_en = emotion['label']
    score = emotion['score']
    
    if score >= THRESHOLD:
        label_ukr = EMOTION_MAP.get(label_en, label_en)
        tag = TAGS.get(label_en, '') 
        
        print(f"  Емоція: **{label_ukr}** | Ймовірність: **{score:.4f}** {tag}")

print("==============================================")
