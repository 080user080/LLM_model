import os
import sys
import importlib
import inspect
from pathlib import Path
import time
from colorama import Fore, Back, Style, init

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ colorama
init(autoreset=True)

# –î–æ–¥–∞—Ç–∏ —à–ª—è—Ö–∏ –¥–æ CUDA –±—ñ–±–ª—ñ–æ—Ç–µ–∫
venv_path = sys.prefix
nvidia_paths = [
    os.path.join(venv_path, 'Lib', 'site-packages', 'nvidia', 'cublas', 'bin'),
    os.path.join(venv_path, 'Lib', 'site-packages', 'nvidia', 'cudnn', 'bin'),
    os.path.join(venv_path, 'Lib', 'site-packages', 'nvidia', 'cuda_runtime', 'bin'),
]

for path in nvidia_paths:
    if os.path.exists(path):
        os.environ['PATH'] = path + os.pathsep + os.environ['PATH']
        try:
            os.add_dll_directory(path)
        except:
            pass

import sounddevice as sd
import numpy as np
from faster_whisper import WhisperModel
import requests
import json
import re

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
SAMPLE_RATE = 16000
LISTEN_DURATION = 4  # –°–∫—ñ–ª—å–∫–∏ —Å–ª—É—Ö–∞—Ç–∏ –¥–ª—è –ø–æ—à—É–∫—É –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó
COMMAND_DURATION = 6  # –°–∫—ñ–ª—å–∫–∏ –∑–∞–ø–∏—Å—É–≤–∞—Ç–∏ –∫–æ–º–∞–Ω–¥—É
ACTIVATION_WORD = "–∫–ª–∞—Ä–∞"  # –ù–û–í–ï - –ª–µ–≥–∫–µ —Å–ª–æ–≤–æ –¥–ª—è —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è
LM_STUDIO_URL = "http://localhost:1234/v1/chat/completions"

# –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –≥—É—á–Ω—ñ—Å—Ç—å –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó (–∑–∞—Ö–∏—Å—Ç –≤—ñ–¥ —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º—É)
VOLUME_THRESHOLD = 0.01

# –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ –¥–ª—è core –º–æ–¥—É–ª—ñ–≤
dispatcher = None
cache_manager = None
streaming_handler = None

class FunctionRegistry:
    """–†–µ—î—Å—Ç—Ä —Ñ—É–Ω–∫—Ü—ñ–π –∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–º –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è–º"""
    
    def __init__(self):
        self.functions = {}
        self.core_modules = {}
        self.load_all_modules()
    
    def load_all_modules(self):
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –≤—Å—ñ –º–æ–¥—É–ª—ñ –∑ –ø–∞–ø–∫–∏ functions"""
        functions_dir = Path(__file__).parent / "functions"
        
        if not functions_dir.exists():
            print(f"{Fore.YELLOW}‚ö†Ô∏è  –ü–∞–ø–∫–∞ functions –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞. –°—Ç–≤–æ—Ä—é—é...")
            functions_dir.mkdir()
            (functions_dir / "__init__.py").touch()
            return
        
        # –°–ø–æ—á–∞—Ç–∫—É –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ CORE –º–æ–¥—É–ª—ñ (core_*.py) - —É –ø–æ—Ä—è–¥–∫—É —ñ–º–µ–Ω—ñ —Ñ–∞–π–ª—É
        print(f"{Fore.CYAN}üì¶ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è core –º–æ–¥—É–ª—ñ–≤...")
        core_files = sorted(functions_dir.glob("core_*.py"))
        
        for file_path in core_files:
            module_name = file_path.stem
            try:
                spec = importlib.util.spec_from_file_location(module_name, file_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                self.core_modules[module_name] = module
                print(f"{Fore.MAGENTA}‚ö° Core: {Fore.CYAN}{module_name}")
                
                # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ core –º–æ–¥—É–ª—å —è–∫—â–æ —î —Ñ—É–Ω–∫—Ü—ñ—è init
                if hasattr(module, 'init'):
                    module.init()
                    
            except Exception as e:
                print(f"{Fore.RED}‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è {module_name}: {e}")
        
        # –ü–æ—Ç—ñ–º –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–≤–∏—á–∞–π–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó (aaa_*.py)
        print(f"\n{Fore.CYAN}üì¶ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ—É–Ω–∫—Ü—ñ–π...")
        for file_path in sorted(functions_dir.glob("aaa_*.py")):
            module_name = file_path.stem
            try:
                spec = importlib.util.spec_from_file_location(module_name, file_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                for name, obj in inspect.getmembers(module):
                    if inspect.isfunction(obj) and hasattr(obj, '_is_llm_function'):
                        func_info = {
                            'function': obj,
                            'name': obj._function_name,
                            'description': obj._description,
                            'parameters': obj._parameters
                        }
                        self.functions[obj._function_name] = func_info
                        print(f"{Fore.GREEN}‚úÖ {Fore.CYAN}{obj._function_name}")
            
            except Exception as e:
                print(f"{Fore.RED}‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è {module_name}: {e}")
    
    def get_core_module(self, name):
        """–û—Ç—Ä–∏–º–∞—Ç–∏ core –º–æ–¥—É–ª—å –∑–∞ –Ω–∞–∑–≤–æ—é"""
        for module_name, module in self.core_modules.items():
            if name in module_name:
                return module
        return None
    
    def get_system_prompt(self):
        """–ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ system prompt –∑ –æ–ø–∏—Å–æ–º –≤—Å—ñ—Ö —Ñ—É–Ω–∫—Ü—ñ–π"""
        if not self.functions:
            return "–¢–∏ –∫–æ—Ä–∏—Å–Ω–∏–π –∞—Å–∏—Å—Ç–µ–Ω—Ç –Ω–∞ —ñ–º'—è –ö–ª–∞—Ä–∞. –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é –∫–æ—Ä–æ—Ç–∫–æ —ñ –ø–æ —Å—É—Ç—ñ."
        
        prompt = """–¢–∏ –∫–æ—Ä–∏—Å–Ω–∏–π –∞—Å–∏—Å—Ç–µ–Ω—Ç –Ω–∞ —ñ–º'—è –ö–ª–∞—Ä–∞. –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é –∫–æ—Ä–æ—Ç–∫–æ —ñ –ø–æ —Å—É—Ç—ñ.

–î–û–°–¢–£–ü–ù–Ü –§–£–ù–ö–¶–Ü–á:
"""
        for func_name, func_info in self.functions.items():
            prompt += f"\n{func_info['name']} - {func_info['description']}\n"
            prompt += "–ü–∞—Ä–∞–º–µ—Ç—Ä–∏:\n"
            for param_name, param_desc in func_info['parameters'].items():
                prompt += f"  - {param_name}: {param_desc}\n"
        
        prompt += """
–í–ê–ñ–õ–ò–í–û! –ö–æ–ª–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –ø—Ä–æ—Å–∏—Ç—å –≤–∏–∫–æ–Ω–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é, –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–π –¢–Ü–õ–¨–ö–ò —á–∏—Å—Ç–∏–º JSON:
{"action":"–Ω–∞–∑–≤–∞_—Ñ—É–Ω–∫—Ü—ñ—ó","–ø–∞—Ä–∞–º–µ—Ç—Ä1":"–∑–Ω–∞—á–µ–Ω–Ω—è1","–ø–∞—Ä–∞–º–µ—Ç—Ä2":"–∑–Ω–∞—á–µ–Ω–Ω—è2"}

–ü—Ä–∏–∫–ª–∞–¥: {"action":"create_file","filename":"test.txt","content":"–ü—Ä–∏–≤—ñ—Ç —Å–≤—ñ—Ç"}

–Ø–∫—â–æ —Ü–µ –∑–≤–∏—á–∞–π–Ω–∞ —Ä–æ–∑–º–æ–≤–∞, –ø—Ä–æ—Å—Ç–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–π —Ç–µ–∫—Å—Ç–æ–º."""
        
        return prompt
    
    def execute_function(self, action, params):
        """–í–∏–∫–æ–Ω–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é –∑–∞ –Ω–∞–∑–≤–æ—é"""
        if action not in self.functions:
            return f"{Fore.RED}‚ùå –§—É–Ω–∫—Ü—ñ—è {action} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞"
        
        try:
            func = self.functions[action]['function']
            result = func(**params)
            return result
        except Exception as e:
            return f"{Fore.RED}‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è {action}: {str(e)}"

def extract_json_from_text(text):
    """–í–∏—Ç—è–≥—Ç–∏ JSON –∑ —Ç–µ–∫—Å—Ç—É"""
    text = re.sub(r'<\|[^|]+\|>', '', text)
    text = re.sub(r'assistant|channel|commentary.*?(?=\{)|to=functions\.\w+|constrain|message', '', text)
    
    json_match = re.search(r'```json\s*(.*?)\s*```', text, re.DOTALL)
    if json_match:
        return json_match.group(1).strip()
    
    json_match = re.search(r'```\s*(.*?)\s*```', text, re.DOTALL)
    if json_match:
        return json_match.group(1).strip()
    
    json_match = re.search(r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}', text, re.DOTALL)
    if json_match:
        return json_match.group(0).strip()
    
    return text.strip()

def ask_llm(user_message, conversation_history, system_prompt):
    """–í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –∑–∞–ø–∏—Ç –¥–æ LM Studio"""
    try:
        messages = [{"role": "system", "content": system_prompt}]
        messages.extend(conversation_history)
        messages.append({"role": "user", "content": user_message})
        
        response = requests.post(LM_STUDIO_URL, 
            json={
                "messages": messages,
                "temperature": 0.3,
                "max_tokens": 1024,
                "stream": False
            },
            timeout=60
        )
        
        if response.status_code == 200:
            return response.json()['choices'][0]['message']['content']
        else:
            return f"–ü–æ–º–∏–ª–∫–∞: {response.status_code}"
    except Exception as e:
        return f"{Fore.RED}‚ùå –ü–æ–º–∏–ª–∫–∞: {str(e)}"

def process_llm_response(response_text, registry):
    """–û–±—Ä–æ–±–∏—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—å LLM —ñ –≤–∏–∫–æ–Ω–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—ó"""
    json_text = extract_json_from_text(response_text)
    
    try:
        response_json = json.loads(json_text)
        
        if "action" in response_json:
            action = response_json.pop("action")
            result = registry.execute_function(action, response_json)
            return result
    except json.JSONDecodeError:
        pass
    
    return response_text

def check_volume(audio):
    """–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ —î –∑–≤—É–∫ (–Ω–µ —Ç–∏—à–∞)"""
    return np.abs(audio).mean() > VOLUME_THRESHOLD

# –í main.py –∑–º—ñ–Ω–∏—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é check_activation_word:
def check_activation_word(text):
    """–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ —î –∞–∫—Ç–∏–≤–∞—Ü—ñ–π–Ω–µ —Å–ª–æ–≤–æ –≤ —Ç–µ–∫—Å—Ç—ñ"""
    text_lower = text.lower().strip()
    
    # –®—É–∫–∞—î–º–æ –±—É–¥—å-—è–∫–µ –ø–æ—à–∏—Ä–µ–Ω–Ω—è —Å–ª–æ–≤–∞ "–∫–ª–∞—Ä–∞" —á–∏ "–¥–∂–∞–≤—ñ—Å"
    patterns = [
        r'–¥–∂–∞[—Ä–≤]{1,2}—ñ?—Å',  # –¥–∂–∞–≤—ñ—Å, –¥–∂–∞—Ä–≤—ñ—Å, –¥–∂–∞–≤–∏—Å
        r'–¥–∂–∞—Ä–≤–∏—Å',  # –∑ –≤–º—ñ—Å—Ç–æ –≤
        r'–¥–∂–∞—Ä–∏—Å'     # –±–µ–∑ –≤
    ]
    
    for pattern in patterns:
        match = re.search(pattern, text_lower)
        if match:
            # –í–∏–¥–∞–ª–∏—Ç–∏ –∞–∫—Ç–∏–≤–∞—Ü—ñ–π–Ω–µ —Å–ª–æ–≤–æ –¢–Ü–õ–¨–ö–ò —è–∫—â–æ –≤–æ–Ω–æ –Ω–∞ –ø–æ—á–∞—Ç–∫—É —Ä–µ—á–µ–Ω–Ω—è
            # –∞–±–æ –ø—ñ—Å–ª—è –∫–æ–º–∏/–ø—Ä–æ–±—ñ–ª—É
            cleaned = re.sub(pattern, '', text_lower, count=1).strip()
            cleaned = re.sub(r'^\s*[,-]\s*', '', cleaned)  # –í–∏–¥–∞–ª–∏—Ç–∏ –∫–æ–º—É/—Ç–∏—Ä–µ –Ω–∞ –ø–æ—á–∞—Ç–∫—É
            cleaned = re.sub(r'\s+', ' ', cleaned)  # –ó–∞–º—ñ–Ω–∏—Ç–∏ –∫—ñ–ª—å–∫–∞ –ø—Ä–æ–±—ñ–ª—ñ–≤ –Ω–∞ –æ–¥–∏–Ω
            
            # –Ø–∫—â–æ –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞–ª–∏—à–∏–ª–∞—Å—è –∫–æ–º–∞–Ω–¥–∞
            if cleaned:
                return True, cleaned
            
            return True, ""  # –¢—ñ–ª—å–∫–∏ –∞–∫—Ç–∏–≤–∞—Ü—ñ–π–Ω–µ —Å–ª–æ–≤–æ
    
    return False, text

class VoiceAssistant:
    def __init__(self, whisper_model, registry, system_prompt):
        self.whisper_model = whisper_model
        self.registry = registry
        self.system_prompt = system_prompt
        self.conversation_history = []
        self.is_listening = True
        
        # –û—Ç—Ä–∏–º–∞—Ç–∏ core –º–æ–¥—É–ª—ñ
        global dispatcher, cache_manager, streaming_handler
        dispatcher_module = registry.get_core_module('dispatcher')
        if dispatcher_module:
            dispatcher = dispatcher_module.Dispatcher(registry)
            print(f"{Fore.MAGENTA}‚ö° –î–∏—Å–ø–µ—Ç—á–µ—Ä –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ")
        
        cache_module = registry.get_core_module('cache')
        if cache_module:
            cache_manager = cache_module.CacheManager()
            print(f"{Fore.MAGENTA}‚ö° –ö–µ—à –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ")
        
        streaming_module = registry.get_core_module('streaming')
        if streaming_module:
            streaming_handler = streaming_module.StreamingHandler(LM_STUDIO_URL)
            print(f"{Fore.MAGENTA}‚ö° –°—Ç—Ä—ñ–º—ñ–Ω–≥ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ")
        
    def listen_continuously(self):
        """–ü–æ—Å—Ç—ñ–π–Ω–æ —Å–ª—É—Ö–∞—Ç–∏ –º—ñ–∫—Ä–æ—Ñ–æ–Ω"""
        print(f"\n{Back.CYAN}{Fore.BLACK} üéß –†–ï–ñ–ò–ú –ü–†–û–°–õ–£–•–û–í–£–í–ê–ù–ù–Ø {Style.RESET_ALL}")
        print(f"{Fore.YELLOW}üí° –°–∫–∞–∂–∏ '{ACTIVATION_WORD.upper()}' + –∫–æ–º–∞–Ω–¥–∞")
        print(f"{Fore.YELLOW}üí° –ü—Ä–∏–∫–ª–∞–¥: '{ACTIVATION_WORD} –≤—ñ–¥–∫—Ä–∏–π –±–ª–æ–∫–Ω–æ—Ç'")
        print(f"{Fore.LIGHTBLACK_EX}üí° Ctrl+C –¥–ª—è –≤–∏—Ö–æ–¥—É\n")
        
        while self.is_listening:
            try:
                # –ó–∞–ø–∏—Å–∞—Ç–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç
                audio = sd.rec(
                    int(LISTEN_DURATION * SAMPLE_RATE),
                    samplerate=SAMPLE_RATE,
                    channels=1,
                    dtype=np.float32,
                    blocking=True
                )
                audio = np.squeeze(audio)
                
                # –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ —î –∑–≤—É–∫ (–∑–∞—Ö–∏—Å—Ç –≤—ñ–¥ —Ç–∏—à—ñ)
                if not check_volume(audio):
                    continue
                
                # –†–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ —à–≤–∏–¥–∫–æ
                segments, info = self.whisper_model.transcribe(
                    audio,
                    language="uk",
                    beam_size=1,
                    vad_filter=True
                )
                
                text = ""
                for seg in segments:
                    text += seg.text
                
                if not text.strip():
                    continue
                
                # –ü–æ–∫–∞–∑–∞—Ç–∏ —â–æ –ø–æ—á—É–ª–∏ (—Å—ñ—Ä–∏–º - –Ω–µ–∞–∫—Ç–∏–≤–æ–≤–∞–Ω–µ)
                print(f"{Fore.LIGHTBLACK_EX}üîâ {text}")
                
                # –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∞–∫—Ç–∏–≤–∞—Ü—ñ–π–Ω–µ —Å–ª–æ–≤–æ
                is_activated, command_text = check_activation_word(text)
                
                if is_activated:
                    print(f"\n{Back.GREEN}{Fore.BLACK} ‚ú® –ê–ö–¢–ò–í–û–í–ê–ù–û! {Style.RESET_ALL}\n")
                    
                    # –Ø–∫—â–æ –ø—ñ—Å–ª—è –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó –≤–∂–µ —î –∫–æ–º–∞–Ω–¥–∞
                    if command_text.strip():
                        print(f"{Fore.BLUE}üí¨ [–ö–æ–º–∞–Ω–¥–∞]: {Fore.WHITE}{command_text}")
                        self.process_command(command_text)
                    else:
                        # –ó–∞–ø–∏—Å–∞—Ç–∏ –∫–æ–º–∞–Ω–¥—É –æ–∫—Ä–µ–º–æ
                        print(f"{Fore.CYAN}üé§ –°–ª—É—Ö–∞—é –∫–æ–º–∞–Ω–¥—É ({COMMAND_DURATION} —Å–µ–∫)...")
                        
                        cmd_audio = sd.rec(
                            int(COMMAND_DURATION * SAMPLE_RATE),
                            samplerate=SAMPLE_RATE,
                            channels=1,
                            dtype=np.float32,
                            blocking=True
                        )
                        cmd_audio = np.squeeze(cmd_audio)
                        
                        print(f"{Fore.YELLOW}üîç –†–æ–∑–ø—ñ–∑–Ω–∞—é...")
                        segments, _ = self.whisper_model.transcribe(cmd_audio, language="uk")
                        
                        command_text = ""
                        for seg in segments:
                            command_text += seg.text
                        
                        if command_text.strip():
                            print(f"{Fore.BLUE}üí¨ [–ö–æ–º–∞–Ω–¥–∞]: {Fore.WHITE}{command_text}")
                            self.process_command(command_text)
                        else:
                            print(f"{Fore.RED}‚ùå –ö–æ–º–∞–Ω–¥—É –Ω–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–Ω–æ")
                    
                    print(f"\n{Fore.CYAN}üéß –ü—Ä–æ–¥–æ–≤–∂—É—é —Å–ª—É—Ö–∞—Ç–∏...\n")
                
            except KeyboardInterrupt:
                print(f"\n\n{Fore.YELLOW}üëã –í–∏–º–∏–∫–∞—é—Å—å...")
                self.is_listening = False
                break
            except Exception as e:
                print(f"{Fore.RED}‚ùå –ü–æ–º–∏–ª–∫–∞: {e}")
                time.sleep(0.5)
    
    def process_command(self, command_text):
        """–û–±—Ä–æ–±–∏—Ç–∏ –∫–æ–º–∞–Ω–¥—É"""
        try:
            start_total = time.time()
            
            # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–µ—à—É
            if cache_manager:
                cached_result = cache_manager.get(command_text)
                if cached_result:
                    print(f"{Fore.YELLOW}‚ö° [–ö–µ—à]")
                    print(f"{Fore.GREEN}ü§ñ [–ö–ª–∞—Ä–∞]: {Fore.WHITE}{cached_result}")
                    print(f"{Fore.LIGHTBLACK_EX}‚è±Ô∏è  0.00—Å")
                    return
            
            # –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —à–≤–∏–¥–∫–∏–π –º–∞—Ä—à—Ä—É—Ç
            if dispatcher:
                quick_result = dispatcher.try_quick_route(command_text)
                if quick_result:
                    elapsed = time.time() - start_total
                    print(f"{Fore.YELLOW}‚ö° [–®–≤–∏–¥–∫–∏–π –º–∞—Ä—à—Ä—É—Ç]")
                    print(f"{Fore.GREEN}ü§ñ [–ö–ª–∞—Ä–∞]: {Fore.WHITE}{quick_result}")
                    print(f"{Fore.LIGHTBLACK_EX}‚è±Ô∏è  {elapsed:.2f}—Å")
                    
                    if cache_manager:
                        cache_manager.set(command_text, quick_result)
                    return
            
            # –ó–≤–∏—á–∞–π–Ω–∏–π LLM –º–∞—Ä—à—Ä—É—Ç
            self.conversation_history.append({"role": "user", "content": command_text})
            
            print(f"{Fore.MAGENTA}ü§î [–î—É–º–∞—é...]")
            start_llm = time.time()
            
            answer = ask_llm(command_text, self.conversation_history, self.system_prompt)
            llm_time = time.time() - start_llm
            
            final_answer = process_llm_response(answer, self.registry)
            
            self.conversation_history.append({"role": "assistant", "content": answer})
            
            if cache_manager and not answer.startswith("{"):
                cache_manager.set(command_text, final_answer)
            
            elapsed = time.time() - start_total
            print(f"{Fore.GREEN}ü§ñ [–ö–ª–∞—Ä–∞]: {Fore.WHITE}{final_answer}")
            print(f"{Fore.LIGHTBLACK_EX}‚è±Ô∏è  {elapsed:.2f}—Å (LLM: {llm_time:.2f}—Å)")
            
            if len(self.conversation_history) > 10:
                self.conversation_history = self.conversation_history[-10:]
                
        except Exception as e:
            print(f"{Fore.RED}‚ùå –ü–æ–º–∏–ª–∫–∞: {e}")

# ==================== –ì–û–õ–û–í–ù–ê –ü–†–û–ì–†–ê–ú–ê ====================

print(f"{Back.BLUE}{Fore.WHITE}{'='*60}")
print(f"{Back.BLUE}{Fore.WHITE}ü§ñ –ö–õ–ê–†–ê - –ì–æ–ª–æ—Å–æ–≤–∏–π –ê—Å–∏—Å—Ç–µ–Ω—Ç v2.1{Style.RESET_ALL}")
print(f"{Back.BLUE}{Fore.WHITE}{'='*60}{Style.RESET_ALL}")

print(f"\n{Fore.CYAN}üîß –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥—É–ª—ñ–≤...")
start_time = time.time()
registry = FunctionRegistry()
load_time = time.time() - start_time
print(f"{Fore.LIGHTBLACK_EX}‚è±Ô∏è  {load_time:.2f}—Å")

print(f"\n{Fore.CYAN}üé§ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è Whisper...")
start_time = time.time()
whisper_model = WhisperModel("large-v3", device="cuda", compute_type="float16") # large-v3 -- –≤–∏—Å–æ–∫–∞ —è–∫—ñ—Å—Ç—å  medium -- —Å–µ—Ä–µ–¥–Ω—è —è–∫—ñ—Å—Ç—å
whisper_time = time.time() - start_time
print(f"{Fore.LIGHTBLACK_EX}‚è±Ô∏è  {whisper_time:.2f}—Å")

print(f"\n{Fore.CYAN}üîå –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ LM Studio...")
try:
    test_response = requests.get("http://localhost:1234/v1/models", timeout=5)
    if test_response.status_code == 200:
        models = test_response.json()
        print(f"{Fore.GREEN}‚úÖ {Fore.YELLOW}{models['data'][0]['id']}")
    else:
        print(f"{Fore.YELLOW}‚ö†Ô∏è  –ü—Ä–æ–±–ª–µ–º–∏ –∑ API")
except:
    print(f"{Fore.RED}‚ùå LM Studio –Ω–µ –∑–∞–ø—É—â–µ–Ω–∏–π!")
    exit()

print(f"\n{Fore.YELLOW}{'='*60}")
print(f"{Fore.YELLOW}üì¶ –§—É–Ω–∫—Ü—ñ–π: {Fore.WHITE}{len(registry.functions)}")
for func_name in registry.functions.keys():
    print(f"{Fore.CYAN}   ‚Ä¢ {func_name}")
print(f"{Fore.YELLOW}{'='*60}{Style.RESET_ALL}")

system_prompt = registry.get_system_prompt()
assistant = VoiceAssistant(whisper_model, registry, system_prompt)
assistant.listen_continuously()
